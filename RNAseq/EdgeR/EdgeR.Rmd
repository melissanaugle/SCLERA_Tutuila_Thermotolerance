---
title: "EdgeR"
author: "Melissa Naugle"
date: "10/26/2021"
output: html_document
---


#Used with Barshis transcriptome reference
#Based on EdgeR tutorial:

#Setup
Load packages and install BiocManager if needed

```{r setup}
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("edgeR")
#install.packages("statmod")
library("edgeR")
library("statmod")
library("data.table")

setwd("~/Desktop/GitHub/RNAseq_allsites_Barshisreference/")
```

Import Data
Note: opened matrix and write 'gene' as first column header from raw file 

```{r import_data}
#Import gene count data and view the first few rows
#had to add 'gene' to first header row on original txt file to prevent weird error
countsTable <- read.table(file="../RSEM.isoform.counts.matrix", row.names="gene", sep="\t", header=TRUE)
head(countsTable)
```

Import grouping factors

Note:  reps txt file must match order of counts matrix

```{r groupingfactors}
#import grouping factor and create samples group matrix
reps <- read.table("coral_samples_can_vat_all_replicates.txt", header = F)

```

Setup grouping factors and create List 

```{r create list}
group <- reps$V1

#create 'DGE list' object
y <- DGEList(counts=countsTable, group = group)

names(countsTable)
y

#MAKE SURE SAME ORDER ON REPS SHEET AS IN COUNTS MATRIX
colnames(y) <- reps$V2


```


Filtering and normalization

Optional alternative filtering (not performed here):
'Here, a gene is only retained if it is expressed at a count-per-million (CPM) above 0.5 in at least two samples
keep <- rowSums(cpm(y) > 0.5) >= 2
summary(keep)'

TMM normalization is performed to eliminate composition biases between libraries.

15109 after filtering
18387 filtered out

```{r norm_and_write_list}

#filter out lowly expressed genes
keep <- filterByExpr(y)

y <- y[keep,,keep.lib.sizes=FALSE]

#view summary of normalized counts
summary(keep)

#normalize library sizes (use trimmed mean m values to eliminate composition biases)
# The default method for computing these scale factors uses a trimmed mean of M-values (TMM) between each pair of samples.
y <- calcNormFactors(y)

#write normalized
normList <- cpm(y, normalized.lib.sizes = T)
nrow(normList)
write.table(normList, file = "glmQLF_normalizedCounts.csv", sep=",", row.names=T)

```

MD plot to verify 

The performance of the TMM normalization procedure can be examined using meandifference (MD) plots. This visualizes the library size-adjusted log-fold change between two libraries (the difference) against the average log-expression across those libraries (the mean). The following MD plot is generated by comparing sample 1 against an artificial library constructed from the average of all other samples.

Ideally, the bulk of genes should be centred at a log-fold change of zero. This indicates that any composition bias between libraries has been successfully removed. This quality check should be repeated by constructing a MD plot for each sample.

```{r plots_to_verify}
#Verify TMM normalization using a MD plot
jpeg("glmQLF_plotNormalizedMD.jpg")
plotMD(cpm(y, log=TRUE), column=1) 
abline(h=0, col="red", lty=2, lwd=2) 
dev.off()
```



## Also create normalized counts for JUST controls, and JUST heats 
Note:  reps txt file must match order of counts matrix

First, controls:
```{r groupingfactors}
countsTable <- read.table(file="../RSEM.isoform.counts.matrix", row.names="gene", sep="\t", header=TRUE)
head(countsTable)
countsTable_controls <- select(countsTable,contains("_E_"))


#import grouping factor and create samples group matrix
reps <- read.table("coral_samples_allsites_controls.txt", header = F)


#Setup grouping factors and create List 
group <- reps$V1

y <- DGEList(counts=countsTable_controls, group = group)

names(countsTable_controls)
y

#MAKE SURE SAME ORDER ON REPS SHEET AS IN COUNTS MATRIX
colnames(y) <- reps$V2

#Filtering and normalization

#filter out lowly expressed genes
keep <- filterByExpr(y)

y <- y[keep,,keep.lib.sizes=FALSE]

#view summary of normalized counts
summary(keep)

#normalize library sizes (use trimmed mean m values to eliminate composition biases)
# The default method for computing these scale factors uses a trimmed mean of M-values (TMM) between each pair of samples.
y <- calcNormFactors(y)

#write normalized
normList <- cpm(y, normalized.lib.sizes = T)
nrow(normList)
write.table(normList, file = "glmQLF_normalizedCounts_controls.csv", sep=",", row.names=T)

```


Heats:
```{r groupingfactors}
countsTable <- read.table(file="../RSEM.isoform.counts.matrix", row.names="gene", sep="\t", header=TRUE)
head(countsTable)
countsTable_heats <- select(countsTable,contains("_H_"))


#import grouping factor and create samples group matrix
reps <- read.table("coral_samples_allsites_heat.txt", header = F)


#Setup grouping factors and create List 
group <- reps$V1

y <- DGEList(counts=countsTable_heats, group = group)

names(countsTable_heats)
y

#MAKE SURE SAME ORDER ON REPS SHEET AS IN COUNTS MATRIX
colnames(y) <- reps$V2

#Filtering and normalization

#filter out lowly expressed genes
keep <- filterByExpr(y)

y <- y[keep,,keep.lib.sizes=FALSE]

#view summary of normalized counts
summary(keep)

#normalize library sizes (use trimmed mean m values to eliminate composition biases)
# The default method for computing these scale factors uses a trimmed mean of M-values (TMM) between each pair of samples.
y <- calcNormFactors(y)

#write normalized
normList <- cpm(y, normalized.lib.sizes = T)
nrow(normList)
write.table(normList, file = "glmQLF_normalizedCounts_heats.csv", sep=",", row.names=T)

```